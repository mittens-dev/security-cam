#!/usr/bin/env python3
"""
Raspberry Pi Camera 3 Security System — Stills-Only Edition (v4)

Uses the official picamera2 patterns:
- Dual stream: main (1280x720) + lores (320x240) for motion detection
- NO video encoding — stills only via captured_request()
- Burst capture on motion detection (lightweight, no hang risk)
"""
import sys
import json
import time
import threading
from datetime import datetime
from pathlib import Path
from flask import Flask, request, jsonify, send_from_directory, send_file
from flask_cors import CORS
from picamera2 import Picamera2
import cv2
import numpy as np
import io
from PIL import Image, ImageEnhance

# === PATHS ===
BASE_DIR = Path(__file__).parent.parent
RECORDINGS_DIR = BASE_DIR / 'recordings'
STILLS_DIR = BASE_DIR / 'stills'
LOGS_DIR = BASE_DIR / 'logs'
CONFIG_FILE = BASE_DIR / 'api' / 'config.json'
EVENTS_FILE = LOGS_DIR / 'motion_events.json'

RECORDINGS_DIR.mkdir(exist_ok=True)
STILLS_DIR.mkdir(exist_ok=True)
LOGS_DIR.mkdir(exist_ok=True)

# === FLASK APP ===
app = Flask(__name__, static_folder=str(BASE_DIR / 'web'), static_url_path='')
CORS(app)

# === STATE ===
config = {
    'motion_threshold': 500,
    'motion_sensitivity': 25,
    'capture_on_motion': True,
    'burst_count': 5,
    'burst_interval': 0.5,
    'cooldown_seconds': 5,
    'detection_regions': [],
    'use_regions': False,
    'save_stills': True,
    'camera_settings': {
        'exposure_time': 8000,
        'analogue_gain': 1.2,
        'brightness': 0,
        'contrast': 1.0,
        'saturation': 1.0,
        'awb_mode': 1,
        'still_saturation': 1.0,
        'still_contrast': 1.0
    }
}

state = {
    'monitoring': False,
    'capturing': False,
    'motion_detected': False,
    'last_motion': None,
    'last_capture_count': 0
}

motion_events = []
camera = None
camera_lock = threading.Lock()
prev_lores = None
stop_flag = threading.Event()
monitor_thread = None

# Low-resolution stream size for motion detection
LORES_SIZE = (320, 240)
MAIN_SIZE = (1280, 720)


# === CONFIG ===

def load_config():
    global config
    try:
        if CONFIG_FILE.exists():
            with open(CONFIG_FILE) as f:
                saved = json.load(f)
                # Migrate old keys
                if 'record_on_motion' in saved and 'capture_on_motion' not in saved:
                    saved['capture_on_motion'] = saved.pop('record_on_motion')
                if 'recording_duration' in saved:
                    saved.pop('recording_duration', None)
                if 'pre_record_seconds' in saved:
                    saved.pop('pre_record_seconds', None)
                config.update(saved)
    except Exception as e:
        print(f"Config error: {e}", flush=True)


def save_config():
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
    except Exception as e:
        print(f"Save config error: {e}", flush=True)


def load_events():
    global motion_events
    try:
        if EVENTS_FILE.exists():
            with open(EVENTS_FILE) as f:
                motion_events = json.load(f)
    except:
        motion_events = []


def save_event(pixels, stills_captured=0):
    now = datetime.now()
    state['motion_detected'] = True
    state['last_motion'] = now.isoformat()

    motion_events.append({
        'timestamp': now.isoformat(),
        'pixels_changed': pixels,
        'stills_captured': stills_captured
    })

    while len(motion_events) > 100:
        motion_events.pop(0)

    try:
        with open(EVENTS_FILE, 'w') as f:
            json.dump(motion_events, f)
    except:
        pass


# === CAMERA ===

def get_camera_controls():
    """Build camera controls dict from config"""
    settings = config.get('camera_settings', {})
    return {
        "ExposureTime": int(settings.get('exposure_time', 8000)),
        "AnalogueGain": float(settings.get('analogue_gain', 1.2)),
        "Brightness": float(settings.get('brightness', 0)),
        "Contrast": float(settings.get('contrast', 1.0)),
        "Saturation": float(settings.get('saturation', 1.0)),
        "AwbMode": int(settings.get('awb_mode', 1)),
        "AeEnable": False
    }


def init_camera():
    """Initialize camera with dual-stream configuration.

    Main stream: 1280x720 RGB888 for stills
    Lores stream: 320x240 YUV420 for cheap motion detection
    No encoder — just camera.start().
    """
    global camera

    if camera is not None:
        try:
            camera.close()
        except:
            pass
        camera = None

    try:
        camera = Picamera2()
        video_config = camera.create_video_configuration(
            main={"size": MAIN_SIZE, "format": "RGB888"},
            lores={"size": LORES_SIZE, "format": "YUV420"},
            controls=get_camera_controls()
        )
        camera.configure(video_config)
        print("Camera initialized (dual-stream, stills-only)", flush=True)
        return True
    except Exception as e:
        print(f"Camera init failed: {e}", flush=True)
        camera = None
        return False


def save_burst_stills(count=5, interval=0.5):
    """Capture a burst of still images from the running camera.

    Uses captured_request() which grabs frames from the main stream.
    No encoder involved — lightweight and safe.
    """
    if not camera or not camera.started:
        return []

    filenames = []
    ts_base = datetime.now().strftime("%Y%m%d_%H%M%S")

    camera_settings = config.get('camera_settings', {})
    still_contrast = camera_settings.get('still_contrast', 1.0)
    still_saturation = camera_settings.get('still_saturation', 1.0)

    for i in range(count):
        try:
            with camera.captured_request() as req:
                frame = req.make_array("main")
                img = Image.fromarray(frame)

                if still_contrast != 1.0:
                    img = ImageEnhance.Contrast(img).enhance(still_contrast)
                if still_saturation != 1.0:
                    img = ImageEnhance.Color(img).enhance(still_saturation)

                filename = f"motion_{ts_base}_burst{i+1}.jpg"
                filepath = STILLS_DIR / filename
                img.save(filepath, 'JPEG', quality=90)
                filenames.append(filename)
                print(f"Burst still {i+1}/{count}: {filename}", flush=True)

            if i < count - 1:
                time.sleep(interval)
        except Exception as e:
            print(f"Burst still {i+1} error: {e}", flush=True)

    return filenames


def build_region_mask():
    """Pre-compute region mask for lores stream dimensions"""
    if not config.get('use_regions') or not config.get('detection_regions'):
        return None

    scale_x = LORES_SIZE[0] / MAIN_SIZE[0]
    scale_y = LORES_SIZE[1] / MAIN_SIZE[1]

    mask = np.zeros((LORES_SIZE[1], LORES_SIZE[0]), dtype=np.uint8)
    for region in config['detection_regions']:
        x1, y1, x2, y2 = region
        lx1 = int(x1 * scale_x)
        ly1 = int(y1 * scale_y)
        lx2 = int(x2 * scale_x)
        ly2 = int(y2 * scale_y)
        mask[ly1:ly2, lx1:lx2] = 255
    return mask


def detect_motion_lores(lores_frame, region_mask=None):
    """Motion detection on the low-resolution YUV420 stream.

    Much faster than processing the full 1280x720 RGB main stream.
    Only uses the Y (luminance) channel from YUV420.
    """
    global prev_lores

    w, h = LORES_SIZE
    gray = lores_frame[:h, :w]
    gray = cv2.GaussianBlur(gray, (21, 21), 0)

    if prev_lores is None:
        prev_lores = gray
        return False, 0, 0

    delta = cv2.absdiff(prev_lores, gray)
    max_diff = int(delta.max())

    if region_mask is not None:
        delta = cv2.bitwise_and(delta, region_mask)

    thresh = cv2.threshold(delta, config['motion_sensitivity'], 255, cv2.THRESH_BINARY)[1]
    pixels = cv2.countNonZero(thresh)

    prev_lores = gray

    motion = pixels > config['motion_threshold']
    return motion, pixels, max_diff


def monitor_loop():
    """Main monitoring loop — stills-only, no video encoding.

    - camera.start() with dual streams (no encoder)
    - Motion detection on lores stream (cheap, non-blocking)
    - On motion: burst-capture stills via captured_request()
    - Cooldown between bursts to prevent flooding
    """
    global prev_lores, state

    print("Monitor loop starting...", flush=True)
    state['monitoring'] = True

    retry_count = 0
    while not stop_flag.is_set() and retry_count < 3:
        if not init_camera():
            print(f"Camera init failed (retry {retry_count+1}/3)", flush=True)
            retry_count += 1
            time.sleep(2)
            continue

        try:
            camera.start()
            time.sleep(0.5)

            # Apply controls after start
            camera.set_controls(get_camera_controls())
            time.sleep(0.3)

            prev_lores = None
            print("Monitoring active (stills-only mode)", flush=True)
            retry_count = 0

            region_mask = build_region_mask()
            cooldown_until = 0

            while not stop_flag.is_set():
                try:
                    current_time = time.time()

                    # Cooldown after a burst capture
                    if current_time < cooldown_until:
                        time.sleep(0.1)
                        continue

                    # Grab lores frame for motion detection
                    lores_frame = camera.capture_array("lores")
                    motion, pixels, max_diff = detect_motion_lores(lores_frame, region_mask)

                    if motion:
                        print(f"Motion: {pixels} px (max_diff={max_diff})", flush=True)

                        if config.get('capture_on_motion', True):
                            state['capturing'] = True
                            burst_count = config.get('burst_count', 5)
                            burst_interval = config.get('burst_interval', 0.5)

                            filenames = save_burst_stills(
                                count=burst_count,
                                interval=burst_interval
                            )

                            state['capturing'] = False
                            state['last_capture_count'] = len(filenames)
                            save_event(pixels, stills_captured=len(filenames))

                            # Cooldown to prevent rapid-fire captures
                            cooldown_seconds = config.get('cooldown_seconds', 5)
                            cooldown_until = time.time() + cooldown_seconds
                            prev_lores = None  # Reset motion baseline
                        else:
                            save_event(pixels, stills_captured=0)
                    else:
                        state['motion_detected'] = False

                    time.sleep(0.05)  # ~20 checks/sec on lores

                except Exception as e:
                    print(f"Frame error: {e}", flush=True)
                    time.sleep(1)

        except Exception as e:
            print(f"Monitor error: {e}", flush=True)
            retry_count += 1

        finally:
            try:
                camera.stop()
            except:
                pass

        if not stop_flag.is_set():
            print(f"Restarting monitor (attempt {retry_count+1})", flush=True)
            time.sleep(1)

    state['monitoring'] = False
    print("Monitoring stopped", flush=True)


# === MANUAL SNAPSHOT ===

def take_snapshot(count=None):
    """Take a burst of stills manually."""
    if not camera or not camera.started:
        return []

    if count is None:
        count = config.get('burst_count', 5)

    state['capturing'] = True
    interval = config.get('burst_interval', 0.5)
    filenames = save_burst_stills(count=count, interval=interval)
    state['capturing'] = False
    state['last_capture_count'] = len(filenames)
    return filenames


# === WEB ROUTES ===

@app.route('/')
def serve_index():
    return send_from_directory(BASE_DIR / 'web', 'index.html')

@app.route('/<path:filename>')
def serve_static(filename):
    return send_from_directory(BASE_DIR / 'web', filename)


# === API ROUTES ===

@app.route('/api/status')
def api_status():
    return jsonify(state)


@app.route('/api/config', methods=['GET', 'PUT', 'POST'])
def api_config():
    global monitor_thread

    if request.method == 'GET':
        return jsonify(config)

    data = request.get_json(silent=True) or {}

    regions_changed = 'detection_regions' in data or 'use_regions' in data

    for k, v in data.items():
        if k in config:
            config[k] = v
    save_config()

    if regions_changed and state['monitoring']:
        print("[API] Regions changed, restarting monitor", flush=True)
        stop_flag.set()
        if monitor_thread and monitor_thread.is_alive():
            monitor_thread.join(timeout=5)
        time.sleep(0.5)
        stop_flag.clear()
        state['monitoring'] = True
        monitor_thread = threading.Thread(target=monitor_loop, daemon=True)
        monitor_thread.start()
        print("[API] Monitor restarted with new mask", flush=True)

    return jsonify({'success': True, 'config': config})


@app.route('/api/monitoring/start', methods=['POST'])
def api_start():
    global state, monitor_thread

    print("[API] Start request", flush=True)

    if state['monitoring']:
        return jsonify({'success': True, 'status': state})

    stop_flag.clear()
    state['monitoring'] = True
    monitor_thread = threading.Thread(target=monitor_loop, daemon=True)
    monitor_thread.start()
    time.sleep(0.5)

    return jsonify({'success': True, 'status': state})


@app.route('/api/monitoring/stop', methods=['POST'])
def api_stop():
    global monitor_thread

    print("[API] Stop request", flush=True)
    stop_flag.set()
    state['monitoring'] = False

    if monitor_thread and monitor_thread.is_alive():
        monitor_thread.join(timeout=5)

    time.sleep(0.5)
    print("[API] Monitoring stopped", flush=True)
    return jsonify({'success': True, 'status': state})


@app.route('/api/snapshot', methods=['POST'])
def api_snapshot():
    """Take a manual snapshot burst"""
    if not state['monitoring']:
        return jsonify({'success': False, 'error': 'Start monitoring first'}), 400

    if state.get('capturing'):
        return jsonify({'success': False, 'error': 'Already capturing'}), 400

    data = request.get_json(silent=True) or {}
    count = data.get('count', config.get('burst_count', 5))
    filenames = take_snapshot(count=count)

    if filenames:
        return jsonify({
            'success': True,
            'filenames': filenames,
            'count': len(filenames),
            'status': state
        })
    return jsonify({'success': False, 'error': 'Snapshot failed'}), 500


# Keep old recording endpoints for backward compat (serves existing MP4s)
@app.route('/api/recording/start', methods=['POST'])
def api_record():
    """Legacy — redirects to snapshot"""
    return api_snapshot()


@app.route('/api/events')
def api_events():
    return jsonify({'events': motion_events[-50:]})


@app.route('/api/recordings')
def api_recordings():
    """Serve any existing MP4 recordings (legacy)"""
    recs = []
    for f in sorted(RECORDINGS_DIR.glob('*.mp4'), reverse=True):
        s = f.stat()
        recs.append({
            'filename': f.name,
            'size': s.st_size,
            'created': datetime.fromtimestamp(s.st_ctime).isoformat(),
            'url': f'/api/recordings/{f.name}'
        })
    return jsonify({'recordings': recs})


@app.route('/api/recordings/<filename>', methods=['GET', 'DELETE'])
def api_recording(filename):
    fp = RECORDINGS_DIR / filename

    if request.method == 'DELETE':
        if fp.exists():
            fp.unlink()
            return jsonify({'success': True})
        return jsonify({'error': 'Not found'}), 404

    if not fp.exists():
        return jsonify({'error': 'Not found'}), 404
    return send_from_directory(RECORDINGS_DIR, filename)


@app.route('/api/preview', methods=['GET'])
def api_preview():
    """Get current camera frame for region drawing"""
    global camera

    if camera is None:
        if not init_camera():
            return jsonify({'error': 'Camera not available'}), 503

    try:
        if not camera.started:
            camera.start()
            time.sleep(0.5)

        with camera.captured_request() as req:
            frame = req.make_array("main")

        img = Image.fromarray(frame)
        buf = io.BytesIO()
        img.save(buf, 'JPEG', quality=85)
        buf.seek(0)

        return send_file(buf, mimetype='image/jpeg')
    except Exception as e:
        print(f"Preview error: {e}", flush=True)
        return jsonify({'error': str(e)}), 500


@app.route('/api/stills', methods=['GET'])
def api_stills():
    stills = []
    for f in sorted(STILLS_DIR.glob('*.jpg'), reverse=True):
        s = f.stat()
        stills.append({
            'filename': f.name,
            'size': s.st_size,
            'created': datetime.fromtimestamp(s.st_ctime).isoformat(),
            'url': f'/api/stills/{f.name}'
        })
    return jsonify({'stills': stills})


@app.route('/api/stills/<filename>', methods=['GET', 'DELETE'])
def api_still(filename):
    fp = STILLS_DIR / filename

    if request.method == 'DELETE':
        if fp.exists():
            fp.unlink()
            return jsonify({'success': True})
        return jsonify({'error': 'Not found'}), 404

    if not fp.exists():
        return jsonify({'error': 'Not found'}), 404
    return send_from_directory(STILLS_DIR, filename)


@app.route('/api/stills/delete-all', methods=['POST'])
def api_delete_all_stills():
    """Delete all stills"""
    count = 0
    for f in STILLS_DIR.glob('*.jpg'):
        try:
            f.unlink()
            count += 1
        except:
            pass
    return jsonify({'success': True, 'deleted': count})


@app.route('/api/camera-settings', methods=['GET', 'PUT'])
def api_camera_settings():
    global camera

    if request.method == 'GET':
        return jsonify(config.get('camera_settings', {}))

    data = request.get_json(silent=True) or {}

    if 'camera_settings' not in config:
        config['camera_settings'] = {}

    config['camera_settings'].update(data)
    save_config()

    # Apply to running camera
    if camera and camera.started:
        try:
            camera.set_controls(get_camera_controls())
            print(f"Camera settings applied: {data}", flush=True)
        except Exception as e:
            print(f"Error applying camera settings: {e}", flush=True)
            return jsonify({'error': str(e)}), 500

    return jsonify({'success': True, 'camera_settings': config.get('camera_settings', {})})


@app.route('/api/frame')
def api_frame():
    """Get current camera frame as JPEG using captured_request()"""
    global camera

    try:
        with camera_lock:
            if not camera:
                if not init_camera():
                    return jsonify({'error': 'Camera initialization failed'}), 503

            if not camera.started:
                camera.start()
                camera.set_controls(get_camera_controls())
                time.sleep(0.5)

        with camera.captured_request() as req:
            frame = req.make_array("main")

        img = Image.fromarray(frame)
        buf = io.BytesIO()
        img.save(buf, 'JPEG', quality=85)
        buf.seek(0)

        return send_file(buf, mimetype='image/jpeg')
    except Exception as e:
        print(f"Frame error: {e}", flush=True)
        return jsonify({'error': str(e)}), 500


@app.route('/api/frame-with-still-processing')
def api_frame_with_still_processing():
    """Get current frame with still image post-processing applied"""
    global camera

    try:
        with camera_lock:
            if not camera:
                if not init_camera():
                    return jsonify({'error': 'Camera initialization failed'}), 503

            if not camera.started:
                camera.start()
                camera.set_controls(get_camera_controls())
                time.sleep(0.5)

        with camera.captured_request() as req:
            frame = req.make_array("main")

        img = Image.fromarray(frame)

        camera_settings = config.get('camera_settings', {})
        still_contrast = camera_settings.get('still_contrast', 1.0)
        still_saturation = camera_settings.get('still_saturation', 1.0)

        if still_contrast != 1.0:
            img = ImageEnhance.Contrast(img).enhance(still_contrast)
        if still_saturation != 1.0:
            img = ImageEnhance.Color(img).enhance(still_saturation)

        buf = io.BytesIO()
        img.save(buf, 'JPEG', quality=85)
        buf.seek(0)

        return send_file(buf, mimetype='image/jpeg')
    except Exception as e:
        print(f"Frame processing error: {e}", flush=True)
        return jsonify({'error': str(e)}), 500


# === MAIN ===

if __name__ == '__main__':
    print("Security Camera API (v4 - Stills Only)", flush=True)
    load_config()
    load_events()
    print(f"Config: {config}", flush=True)
    app.run(host='0.0.0.0', port=5000, threaded=True)
