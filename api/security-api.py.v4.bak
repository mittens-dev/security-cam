#!/usr/bin/env python3
"""
Raspberry Pi Camera 3 Security System
Uses the official picamera2 patterns:
- Dual stream: main (1280x720) + lores (320x240) for motion detection
- Continuous H264 encoding with CircularOutput2 for zero-lag recording
- Still capture via captured_request() without interrupting video
"""
import sys
import json
import time
import threading
from datetime import datetime
from pathlib import Path
from flask import Flask, request, jsonify, send_from_directory, send_file
from flask_cors import CORS
from picamera2 import Picamera2
from picamera2.encoders import H264Encoder
from picamera2.outputs import CircularOutput2, PyavOutput
import cv2
import numpy as np
import io
from PIL import Image, ImageEnhance

# === PATHS ===
BASE_DIR = Path(__file__).parent.parent
RECORDINGS_DIR = BASE_DIR / 'recordings'
STILLS_DIR = BASE_DIR / 'stills'
LOGS_DIR = BASE_DIR / 'logs'
CONFIG_FILE = BASE_DIR / 'api' / 'config.json'
EVENTS_FILE = LOGS_DIR / 'motion_events.json'

RECORDINGS_DIR.mkdir(exist_ok=True)
STILLS_DIR.mkdir(exist_ok=True)
LOGS_DIR.mkdir(exist_ok=True)

# === FLASK APP ===
app = Flask(__name__, static_folder=str(BASE_DIR / 'web'), static_url_path='')
CORS(app)

# === STATE ===
config = {
    'motion_threshold': 500,
    'motion_sensitivity': 25,
    'record_on_motion': True,
    'recording_duration': 10,
    'pre_record_seconds': 3,
    'detection_regions': [],
    'use_regions': False,
    'save_stills': True,
    'camera_settings': {
        'exposure_time': 8000,
        'analogue_gain': 1.2,
        'brightness': 0,
        'contrast': 1.0,
        'saturation': 1.0,
        'awb_mode': 1,
        'still_saturation': 1.0,
        'still_contrast': 1.0
    }
}

state = {
    'monitoring': False,
    'recording': False,
    'motion_detected': False,
    'last_motion': None,
    'recording_end_time': 0
}

motion_events = []
camera = None
camera_lock = threading.Lock()
encoder = None
circular = None
prev_lores = None
stop_flag = threading.Event()
monitor_thread = None

# Low-resolution stream size for motion detection
LORES_SIZE = (320, 240)
MAIN_SIZE = (1280, 720)


# === CONFIG ===

def load_config():
    global config
    try:
        if CONFIG_FILE.exists():
            with open(CONFIG_FILE) as f:
                config.update(json.load(f))
    except Exception as e:
        print(f"Config error: {e}", flush=True)


def save_config():
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
    except Exception as e:
        print(f"Save config error: {e}", flush=True)


def load_events():
    global motion_events
    try:
        if EVENTS_FILE.exists():
            with open(EVENTS_FILE) as f:
                motion_events = json.load(f)
    except:
        motion_events = []


def save_event(pixels):
    now = datetime.now()
    state['motion_detected'] = True
    state['last_motion'] = now.isoformat()

    motion_events.append({
        'timestamp': now.isoformat(),
        'pixels_changed': pixels
    })

    while len(motion_events) > 100:
        motion_events.pop(0)

    try:
        with open(EVENTS_FILE, 'w') as f:
            json.dump(motion_events, f)
    except:
        pass


# === CAMERA ===

def get_camera_controls():
    """Build camera controls dict from config"""
    settings = config.get('camera_settings', {})
    return {
        "ExposureTime": int(settings.get('exposure_time', 8000)),
        "AnalogueGain": float(settings.get('analogue_gain', 1.2)),
        "Brightness": float(settings.get('brightness', 0)),
        "Contrast": float(settings.get('contrast', 1.0)),
        "Saturation": float(settings.get('saturation', 1.0)),
        "AwbMode": int(settings.get('awb_mode', 1)),
        "AeEnable": False
    }


def init_camera():
    """Initialize camera with dual-stream video configuration.

    Main stream: 1280x720 RGB888 for recording and stills
    Lores stream: 320x240 YUV420 for cheap motion detection
    """
    global camera

    if camera is not None:
        try:
            camera.close()
        except:
            pass
        camera = None

    try:
        camera = Picamera2()
        video_config = camera.create_video_configuration(
            main={"size": MAIN_SIZE, "format": "RGB888"},
            lores={"size": LORES_SIZE, "format": "YUV420"},
            controls=get_camera_controls()
        )
        camera.configure(video_config)
        print("Camera initialized (dual-stream)", flush=True)
        return True
    except Exception as e:
        print(f"Camera init failed: {e}", flush=True)
        camera = None
        return False


def save_still_image(frame):
    """Save a still JPEG from the current main stream frame"""
    if not config.get('save_stills', True):
        return None

    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"motion_{ts}.jpg"
    filepath = STILLS_DIR / filename

    try:
        img = Image.fromarray(frame)

        camera_settings = config.get('camera_settings', {})
        still_contrast = camera_settings.get('still_contrast', 1.0)
        still_saturation = camera_settings.get('still_saturation', 1.0)

        if still_contrast != 1.0:
            img = ImageEnhance.Contrast(img).enhance(still_contrast)

        if still_saturation != 1.0:
            img = ImageEnhance.Color(img).enhance(still_saturation)

        img.save(filepath, 'JPEG', quality=90)
        print(f"Still saved: {filename}", flush=True)
        return filename
    except Exception as e:
        print(f"Still save error: {e}", flush=True)
        return None


def save_burst_stills(count=3, interval=0.3):
    """Capture a burst of still images from the running camera.

    Uses captured_request() which grabs frames from the main stream
    without interrupting video encoding.
    """
    if not camera or not camera.started:
        return []

    filenames = []
    ts_base = datetime.now().strftime("%Y%m%d_%H%M%S")

    for i in range(count):
        try:
            with camera.captured_request() as req:
                frame = req.make_array("main")
                img = Image.fromarray(frame)

                camera_settings = config.get('camera_settings', {})
                still_contrast = camera_settings.get('still_contrast', 1.0)
                still_saturation = camera_settings.get('still_saturation', 1.0)

                if still_contrast != 1.0:
                    img = ImageEnhance.Contrast(img).enhance(still_contrast)
                if still_saturation != 1.0:
                    img = ImageEnhance.Color(img).enhance(still_saturation)

                filename = f"motion_{ts_base}_burst{i+1}.jpg"
                filepath = STILLS_DIR / filename
                img.save(filepath, 'JPEG', quality=90)
                filenames.append(filename)
                print(f"Burst still {i+1}/{count}: {filename}", flush=True)

            if i < count - 1:
                time.sleep(interval)
        except Exception as e:
            print(f"Burst still {i+1} error: {e}", flush=True)

    return filenames


def build_region_mask():
    """Pre-compute region mask for lores stream dimensions"""
    if not config.get('use_regions') or not config.get('detection_regions'):
        return None

    # Scale regions from main resolution to lores resolution
    scale_x = LORES_SIZE[0] / MAIN_SIZE[0]
    scale_y = LORES_SIZE[1] / MAIN_SIZE[1]

    mask = np.zeros((LORES_SIZE[1], LORES_SIZE[0]), dtype=np.uint8)
    for region in config['detection_regions']:
        x1, y1, x2, y2 = region
        lx1 = int(x1 * scale_x)
        ly1 = int(y1 * scale_y)
        lx2 = int(x2 * scale_x)
        ly2 = int(y2 * scale_y)
        mask[ly1:ly2, lx1:lx2] = 255
    return mask


def detect_motion_lores(lores_frame, region_mask=None):
    """Motion detection on the low-resolution YUV420 stream.

    Much faster than processing the full 1280x720 RGB main stream.
    Only uses the Y (luminance) channel from YUV420.
    """
    global prev_lores

    w, h = LORES_SIZE
    # YUV420: first h rows of width w are the Y (grayscale) channel
    gray = lores_frame[:h, :w]
    gray = cv2.GaussianBlur(gray, (21, 21), 0)

    if prev_lores is None:
        prev_lores = gray
        return False, 0, 0

    delta = cv2.absdiff(prev_lores, gray)
    max_diff = int(delta.max())

    if region_mask is not None:
        delta = cv2.bitwise_and(delta, region_mask)

    thresh = cv2.threshold(delta, config['motion_sensitivity'], 255, cv2.THRESH_BINARY)[1]
    pixels = cv2.countNonZero(thresh)

    prev_lores = gray

    motion = pixels > config['motion_threshold']
    return motion, pixels, max_diff


def monitor_loop():
    """Main monitoring loop using official picamera2 patterns.

    - Continuous H264 encoding with CircularOutput2 (pre-buffer)
    - Motion detection on lores stream (cheap, non-blocking)
    - Still capture via captured_request() (does not interrupt recording)
    - When motion triggers: open_output() starts writing mp4 immediately
    """
    global prev_lores, state, encoder, circular

    print("Monitor loop starting...", flush=True)
    state['monitoring'] = True

    retry_count = 0
    while not stop_flag.is_set() and retry_count < 3:
        if not init_camera():
            print(f"Camera init failed (retry {retry_count+1}/3)", flush=True)
            retry_count += 1
            time.sleep(2)
            continue

        try:
            # Set up continuous H264 encoding with circular buffer
            pre_record = config.get('pre_record_seconds', 3)
            encoder = H264Encoder(bitrate=4000000, repeat=True)
            circular = CircularOutput2(buffer_duration_ms=pre_record * 1000)

            camera.start()
            time.sleep(0.5)

            # Reapply controls after start (ensures they take effect)
            camera.set_controls(get_camera_controls())
            time.sleep(0.3)

            # Start the encoder - it runs continuously, buffering frames
            camera.start_recording(encoder, circular)

            prev_lores = None
            print("Monitoring active (continuous encoding with circular buffer)", flush=True)
            retry_count = 0

            region_mask = build_region_mask()
            recording = False
            recording_end_time = 0
            cooldown_until = 0

            while not stop_flag.is_set():
                try:
                    current_time = time.time()

                    # Check if a recording needs to stop
                    if recording and current_time >= recording_end_time:
                        try:
                            circular.close_output()
                            print("Recording stopped (circular output closed)", flush=True)
                        except Exception as e:
                            print(f"Error closing output: {e}", flush=True)
                        recording = False
                        state['recording'] = False
                        state['recording_end_time'] = current_time
                        cooldown_until = current_time + 2
                        prev_lores = None  # Reset motion baseline

                    # Cooldown after recording
                    if current_time < cooldown_until:
                        time.sleep(0.1)
                        continue

                    # Grab lores frame for motion detection (very fast)
                    lores_frame = camera.capture_array("lores")
                    motion, pixels, max_diff = detect_motion_lores(lores_frame, region_mask)

                    if motion:
                        print(f"Motion: {pixels} px (max_diff={max_diff})", flush=True)
                        save_event(pixels)

                        if not recording and config['record_on_motion']:
                            # Capture burst of stills immediately
                            save_burst_stills(count=3, interval=0.2)

                            # Start recording - includes pre-buffer footage!
                            duration = config['recording_duration']
                            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
                            filename = f"motion_{ts}.mp4"
                            filepath = RECORDINGS_DIR / filename

                            try:
                                circular.open_output(PyavOutput(str(filepath)))
                                recording = True
                                recording_end_time = current_time + duration
                                state['recording'] = True
                                state['recording_end_time'] = recording_end_time
                                print(f"Recording: {filename} ({duration}s + {pre_record}s pre-buffer)", flush=True)
                            except Exception as e:
                                print(f"Record start error: {e}", flush=True)

                        elif recording:
                            # Motion still ongoing - extend recording
                            new_end = current_time + config['recording_duration']
                            if new_end > recording_end_time:
                                recording_end_time = new_end
                                state['recording_end_time'] = recording_end_time
                    else:
                        state['motion_detected'] = False

                    time.sleep(0.05)  # ~20 checks/sec on lores is plenty

                except Exception as e:
                    print(f"Frame error: {e}", flush=True)
                    time.sleep(1)

        except Exception as e:
            print(f"Monitor error: {e}", flush=True)
            retry_count += 1

        finally:
            try:
                if recording:
                    circular.close_output()
                camera.stop_recording()
            except:
                pass
            try:
                camera.stop()
            except:
                pass
            encoder = None
            circular = None

        if not stop_flag.is_set():
            print(f"Restarting monitor (attempt {retry_count+1})", flush=True)
            time.sleep(1)

    state['monitoring'] = False
    print("Monitoring stopped", flush=True)


# === MANUAL RECORDING ===

def record_clip(duration):
    """Manual recording using circular buffer"""
    global state, circular

    if state['recording']:
        return None

    if not circular:
        print("Cannot record: monitoring not active", flush=True)
        return None

    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"manual_{ts}.mp4"
    filepath = RECORDINGS_DIR / filename

    # Capture burst of stills
    save_burst_stills(count=3, interval=0.2)

    try:
        state['recording'] = True
        state['recording_end_time'] = time.time() + duration
        circular.open_output(PyavOutput(str(filepath)))
        print(f"Manual recording: {filename}", flush=True)

        def stop_after_duration():
            time.sleep(duration)
            try:
                circular.close_output()
                print(f"Manual recording saved: {filename}", flush=True)
            except Exception as e:
                print(f"Error stopping manual recording: {e}", flush=True)
            finally:
                state['recording'] = False
                state['recording_end_time'] = time.time()

        threading.Thread(target=stop_after_duration, daemon=True).start()
        return filename

    except Exception as e:
        print(f"Manual record error: {e}", flush=True)
        state['recording'] = False
        return None


# === WEB ROUTES ===

@app.route('/')
def serve_index():
    return send_from_directory(BASE_DIR / 'web', 'index.html')

@app.route('/<path:filename>')
def serve_static(filename):
    return send_from_directory(BASE_DIR / 'web', filename)


# === API ROUTES ===

@app.route('/api/status')
def api_status():
    return jsonify(state)


@app.route('/api/config', methods=['GET', 'PUT', 'POST'])
def api_config():
    global monitor_thread

    if request.method == 'GET':
        return jsonify(config)

    data = request.get_json(silent=True) or {}

    regions_changed = 'detection_regions' in data or 'use_regions' in data

    for k, v in data.items():
        if k in config:
            config[k] = v
    save_config()

    if regions_changed and state['monitoring']:
        print("[API] Regions changed, restarting monitor", flush=True)
        stop_flag.set()
        if monitor_thread and monitor_thread.is_alive():
            monitor_thread.join(timeout=5)
        time.sleep(0.5)
        stop_flag.clear()
        state['monitoring'] = True
        monitor_thread = threading.Thread(target=monitor_loop, daemon=True)
        monitor_thread.start()
        print("[API] Monitor restarted with new mask", flush=True)

    return jsonify({'success': True, 'config': config})


@app.route('/api/monitoring/start', methods=['POST'])
def api_start():
    global state, monitor_thread

    print("[API] Start request", flush=True)

    if state['monitoring']:
        return jsonify({'success': True, 'status': state})

    stop_flag.clear()
    state['monitoring'] = True
    monitor_thread = threading.Thread(target=monitor_loop, daemon=True)
    monitor_thread.start()
    time.sleep(0.5)

    return jsonify({'success': True, 'status': state})


@app.route('/api/monitoring/stop', methods=['POST'])
def api_stop():
    global monitor_thread

    print("[API] Stop request", flush=True)
    stop_flag.set()
    state['monitoring'] = False

    if monitor_thread and monitor_thread.is_alive():
        monitor_thread.join(timeout=5)

    time.sleep(0.5)
    print("[API] Monitoring stopped", flush=True)
    return jsonify({'success': True, 'status': state})


@app.route('/api/recording/start', methods=['POST'])
def api_record():
    if not state['monitoring']:
        return jsonify({'success': False, 'error': 'Start monitoring first'}), 400

    if state['recording']:
        return jsonify({'success': False, 'error': 'Already recording'}), 400

    data = request.get_json(silent=True) or {}
    dur = data.get('duration', config['recording_duration'])
    result = record_clip(dur)

    if result:
        return jsonify({'success': True, 'status': state})
    return jsonify({'success': False, 'error': 'Recording failed'}), 500


@app.route('/api/recording/stop', methods=['POST'])
def api_stop_record():
    return jsonify({'success': True, 'status': state})


@app.route('/api/events')
def api_events():
    return jsonify({'events': motion_events[-50:]})


@app.route('/api/recordings')
def api_recordings():
    recs = []
    for f in sorted(RECORDINGS_DIR.glob('*.mp4'), reverse=True):
        s = f.stat()
        recs.append({
            'filename': f.name,
            'size': s.st_size,
            'created': datetime.fromtimestamp(s.st_ctime).isoformat(),
            'url': f'/api/recordings/{f.name}'
        })
    return jsonify({'recordings': recs})


@app.route('/api/recordings/<filename>', methods=['GET', 'DELETE'])
def api_recording(filename):
    fp = RECORDINGS_DIR / filename

    if request.method == 'DELETE':
        if fp.exists():
            fp.unlink()
            return jsonify({'success': True})
        return jsonify({'error': 'Not found'}), 404

    if not fp.exists():
        return jsonify({'error': 'Not found'}), 404
    return send_from_directory(RECORDINGS_DIR, filename)


@app.route('/api/preview', methods=['GET'])
def api_preview():
    """Get current camera frame for region drawing"""
    global camera

    if camera is None:
        if not init_camera():
            return jsonify({'error': 'Camera not available'}), 503

    try:
        if not camera.started:
            camera.start()
            time.sleep(0.5)

        with camera.captured_request() as req:
            frame = req.make_array("main")

        img = Image.fromarray(frame)
        buf = io.BytesIO()
        img.save(buf, 'JPEG', quality=85)
        buf.seek(0)

        return send_file(buf, mimetype='image/jpeg')
    except Exception as e:
        print(f"Preview error: {e}", flush=True)
        return jsonify({'error': str(e)}), 500


@app.route('/api/stills', methods=['GET'])
def api_stills():
    stills = []
    for f in sorted(STILLS_DIR.glob('*.jpg'), reverse=True):
        s = f.stat()
        stills.append({
            'filename': f.name,
            'size': s.st_size,
            'created': datetime.fromtimestamp(s.st_ctime).isoformat(),
            'url': f'/api/stills/{f.name}'
        })
    return jsonify({'stills': stills})


@app.route('/api/stills/<filename>', methods=['GET', 'DELETE'])
def api_still(filename):
    fp = STILLS_DIR / filename

    if request.method == 'DELETE':
        if fp.exists():
            fp.unlink()
            return jsonify({'success': True})
        return jsonify({'error': 'Not found'}), 404

    if not fp.exists():
        return jsonify({'error': 'Not found'}), 404
    return send_from_directory(STILLS_DIR, filename)


@app.route('/api/camera-settings', methods=['GET', 'PUT'])
def api_camera_settings():
    global camera

    if request.method == 'GET':
        return jsonify(config.get('camera_settings', {}))

    data = request.get_json(silent=True) or {}

    if 'camera_settings' not in config:
        config['camera_settings'] = {}

    config['camera_settings'].update(data)
    save_config()

    # Apply to running camera
    if camera and camera.started:
        try:
            camera.set_controls(get_camera_controls())
            print(f"Camera settings applied: {data}", flush=True)
        except Exception as e:
            print(f"Error applying camera settings: {e}", flush=True)
            return jsonify({'error': str(e)}), 500

    return jsonify({'success': True, 'camera_settings': config.get('camera_settings', {})})


@app.route('/api/frame')
def api_frame():
    """Get current camera frame as JPEG using captured_request()"""
    global camera

    try:
        with camera_lock:
            if not camera:
                if not init_camera():
                    return jsonify({'error': 'Camera initialization failed'}), 503

            if not camera.started:
                camera.start()
                camera.set_controls(get_camera_controls())
                time.sleep(0.5)

        # Use captured_request - works whether encoder is running or not
        with camera.captured_request() as req:
            frame = req.make_array("main")

        img = Image.fromarray(frame)
        buf = io.BytesIO()
        img.save(buf, 'JPEG', quality=85)
        buf.seek(0)

        return send_file(buf, mimetype='image/jpeg')
    except Exception as e:
        print(f"Frame error: {e}", flush=True)
        return jsonify({'error': str(e)}), 500


@app.route('/api/frame-with-still-processing')
def api_frame_with_still_processing():
    """Get current frame with still image post-processing applied"""
    global camera

    try:
        with camera_lock:
            if not camera:
                if not init_camera():
                    return jsonify({'error': 'Camera initialization failed'}), 503

            if not camera.started:
                camera.start()
                camera.set_controls(get_camera_controls())
                time.sleep(0.5)

        with camera.captured_request() as req:
            frame = req.make_array("main")

        img = Image.fromarray(frame)

        camera_settings = config.get('camera_settings', {})
        still_contrast = camera_settings.get('still_contrast', 1.0)
        still_saturation = camera_settings.get('still_saturation', 1.0)

        if still_contrast != 1.0:
            img = ImageEnhance.Contrast(img).enhance(still_contrast)
        if still_saturation != 1.0:
            img = ImageEnhance.Color(img).enhance(still_saturation)

        buf = io.BytesIO()
        img.save(buf, 'JPEG', quality=85)
        buf.seek(0)

        return send_file(buf, mimetype='image/jpeg')
    except Exception as e:
        print(f"Frame processing error: {e}", flush=True)
        return jsonify({'error': str(e)}), 500


# === MAIN ===

if __name__ == '__main__':
    print("Security Camera API (v3 - CircularOutput2)", flush=True)
    load_config()
    load_events()
    print(f"Config: {config}", flush=True)
    app.run(host='0.0.0.0', port=5000, threaded=True)
